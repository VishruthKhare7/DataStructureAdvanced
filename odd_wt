using namespace std; 
  
// This function returns true if the current subpart 
// of the forest is two colorable, else false. 
bool twoColorUtil(vector<int>G[], int src, int N,  
                                  int colorArr[]) { 
      
    // Assign first color to source 
    colorArr[src] = 1; 
      
    // Create a queue (FIFO) of vertex numbers and 
    // enqueue source vertex for BFS traversal 
    queue <int> q; 
    q.push(src); 
      
    // Run while there are vertices in queue  
    // (Similar to BFS) 
    while (!q.empty()){ 
          
        int u = q.front(); 
        q.pop(); 
          
        // Find all non-colored adjacent vertices 
        for (int v = 0; v < G[u].size(); ++v){ 
       
            // An edge from u to v exists and 
            // destination v is not colored 
            if (colorArr[G[u][v]] == -1){ 
              
                // Assign alternate color to this  
                // adjacent v of u 
                colorArr[G[u][v]] = 1 - colorArr[u]; 
                q.push(G[u][v]); 
            } 
  
            //  An edge from u to v exists and destination 
            // v is colored with same color as u 
            else if (colorArr[G[u][v]] == colorArr[u])            
                return false; 
        } 
    } 
    return true; 
} 
